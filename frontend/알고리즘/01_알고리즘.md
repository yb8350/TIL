### 2. ì •ë ¬

- **ì •ë ¬ :** ë°°ì—´ ë‚´ ì›ì†Œë“¤ì„ ë²ˆí˜¸ìˆœì´ë‚˜ ì‚¬ì „ ìˆœì„œì™€ ê°™ì´ ì¼ì •í•œ ìˆœì„œëŒ€ë¡œ ì—´ê±°í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜
    
    ğŸ“ ëŒ€í‘œ ì •ë ¬ ì•Œê³ ë¦¬ì¦˜ ë³„ êµ¬í˜„ í•¨ìˆ˜
    
    - ê±°í’ˆì •ë ¬ : ì„œë¡œ ì¸ì ‘í•œ ë‘ ì›ì†Œë¥¼ ë¹„êµí•˜ë©´ì„œ ì •ë ¬í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜ â‡’ O(n^2)
    
    ```jsx
    let swap = function (arr, idx_1, idx_2) {
      let tmp = arr[idx_1];
      arr[idx_1] = arr[idx_2];
      arr[idx_2] = tmp;
    };
    let bubbleSort_1 = function (arr) {
      for (let i = 0; i < arr.length - 1; i++) {
        for (let j = 0; j < arr.length - 1; j++) {
          if (arr[j] > arr[j + 1]) {
            swap(arr, j, j + 1);
          }
        }
      }
    };
    let bubbleSort_2 = function (arr) {
      for (let i = 0; i < arr.length - 1; i++) {
        for (let j = 0; j < arr.length - i - 1; j++) {
          if (arr[j] > arr[j + 1]) {
            swap(arr, j, j + 1);
          }
        }
      }
    };
    
    let bubbleSort_3 = function (arr) {
      let swapped;
      for (let i = 0; i < arr.length - 1; i++) {
        swapped = false;
        for (let j = 0; j < arr.length - i - 1; j++) {
          if (arr[j] > arr[j + 1]) {
            swap(arr, j, j + 1);
            swapped = true;
          }
        }
        if (!swapped) break;
      }
    };
    
    let swap = function (arr, idx_1, idx_2) {
      let tmp = arr[idx_1];
      arr[idx_1] = arr[idx_2];
      arr[idx_2] = tmp;
    };
    let ascending = function (x, y) {
      return x > y;
    };
    let descending = function (x, y) {
      return x < y;
    };
    let bubbleSort = function (arr, compare) {
      for (let i = 0; i < arr.length - 1; i++) {
        for (let j = 0; j < arr.length - i - 1; j++) {
          if (compare(arr[j], arr[j + 1])) {
            swap(arr, j, j + 1);
          }
        }
      }
    };
    ```
    
    - ì„ íƒì •ë ¬ : ìµœì†Ÿê°’ì„ ì°¾ì•„ ë°ì´í„° ì˜ì—­ì˜ ê°€ì¥ ì•ìœ¼ë¡œ ì´ë™í•˜ëŠ” ë°©ì‹ì„ ë°˜ë³µí•˜ì—¬ ì „ì²´ ë°ì´í„° ì˜ì—­ì„ ì •ë ¬í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜ â‡’ O(n^2)
    
    ```jsx
    let swap = function (arr, idx_1, idx_2) {
      let tmp = arr[idx_1];
      arr[idx_1] = arr[idx_2];
      arr[idx_2] = tmp;
    };
    let ascending = function (x, y) {
      return x > y;
    };
    let descending = function (x, y) {
      return x < y;
    };
    let selectionSort = function (arr, compare) {
      for (let i = 0; i < arr.length; i++) {
        let k = i;
        for (let j = i + 1; j < arr.length; j++) {
          if (compare(arr[k], arr[j])) k = j;
        }
        swap(arr, i, k);
      }
    };
    ```
    
    - ì‚½ì…ì •ë ¬ : ì´ë¯¸ ì •ë ¬ëœ ë°ì´í„° ì˜ì—­ê³¼ ë¹„êµí•˜ë©´ì„œ, ìì‹ ì˜ ìœ„ì¹˜ë¥¼ ì°¾ì•„ ìš”ì†Œë¥¼ ì‚½ì…í•˜ì—¬ ì •ë ¬í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜ â‡’ O(n^2)
    
    ```jsx
    let swap = function (arr, idx_1, idx_2) {
      let tmp = arr[idx_1];
      arr[idx_1] = arr[idx_2];
      arr[idx_2] = tmp;
    };
    let ascending = function (x, y) {
      return x > y;
    };
    let descending = function (x, y) {
      return x < y;
    };
    let insertionSort = function (arr, compare) {
      for (let i = 1; i < arr.length; i++) {
        let tmp = arr[i];
        let j;
        for (j = i - 1; j >= 0; j--) {
          arr[j + 1] = arr[j];
          if (compare(tmp, arr[j])) {
            break;
          }
        }
        arr[j + 1] = tmp;
      }
    };
    ```
    
    - ë³‘í•©ì •ë ¬ : í•˜ë‚˜ì˜ ë°°ì—´ì„ ë‘ ê°œì˜ ê· ë“±í•œ í¬ê¸°ë¡œ ë¶„í• í•˜ê³ , ë¶€ë¶„ ì •ë ¬í•˜ë©°, ì´ë¥¼ ë‹¤ì‹œ í•©í•˜ë©´ì„œ ì „ì²´ë¥¼ ì •ë ¬í•´ê°€ëŠ” ì•Œê³ ë¦¬ì¦˜ â‡’ O(n log n)
    
    ```jsx
    let mergeSort = function (arr, compare) {
      if (arr.length === 1) return arr;
      let m = (arr.length / 2).toFixed(0);
      let left = mergeSort(arr.slice(0, m), compare);
      let right = mergeSort(arr.slice(m), compare);
      let i = 0,
        j = 0,
        k = 0;
      while (i < left.length && j < right.length) {
        arr[k++] = compare(left[i], right[j]) ? right[j++] : left[i++];
      }
      while (i < left.length) arr[k++] = left[i++];
      while (j < right.length) arr[k++] = right[j++];
      return arr;
    };
    ```
    
    - í€µì •ë ¬ : íŠ¹ì •í•œ ê°’ì„ ê¸°ì¤€ìœ¼ë¡œ í° ìˆ«ìì™€ ì‘ì€ ìˆ«ìë¥¼ ë¶„í• í•˜ì—¬ ì •ë ¬í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜ â‡’ O(n log n)
    
    ```jsx
    let quickSort = function (arr, compare, s = 0, e = arr.length - 1) {
      let start = s;
      let pivot = arr[e];
      for (let i = s; i <= e; i++) {
        if (compare(pivot, arr[i])) {
          swap(arr, start, i);
          start++;
        }
      }
      swap(arr, start, e);
      if (start - 1 > s) quickSort(arr, compare, s, start - 1);
      if (start + 1 < e) quickSort(arr, compare, start + 1, e);
    };
    ```
    

### 9. ì´ì§„ê²€ìƒ‰

- ì´ì§„ ê²€ìƒ‰ : ìë£Œ êµ¬ì¡° ê¸°ë°˜ìœ¼ë¡œ ì •ë ¬ë˜ì–´ ìˆëŠ” ë°ì´í„° ì•ˆì—ì„œ íŠ¹ì • ê°’ì„ ì°¾ëŠ” ê¸°ë²•
    - í‰ê·  ì‹œê°„ ë³µì¡ë„ : O(log n)

```jsx
// binarySearch_loop(): ë°˜ë³µë¬¸ ê¸°ë°˜ì˜ ì´ì§„ ê²€ìƒ‰
function binarySearch_loop(arr, n) {
  let lowIndex = 0;
  let midIndex = 0;
  let highIndex = arr.length - 1;
  while (lowIndex <= highIndex) {
    midIndex = Math.floor((lowIndex + highIndex) / 2);
    if (arr[midIndex] > n) {
      highIndex = midIndex - 1;
    } else if (arr[midIndex] < n) {
      lowIndex = midIndex + 1;
    } else {
      return midIndex;
    }
  }
  return -1;
}

// binarySearch_recursive(): ì¬ê·€ í•¨ìˆ˜ ê¸°ë°˜ì˜ ì´ì§„ ê²€ìƒ‰
function binarySearch_recursive(
  arr,
  n,
  lowIndex = 0,
  highIndex = arr.length - 1
) {
  if (highIndex < lowIndex) return -1;
  let midIndex = Math.floor((lowIndex + highIndex) / 2);
  if (arr[midIndex] > n) {
    return binarySearch_recursive(arr, n, lowIndex, midIndex - 1);
  } else if (arr[midIndex] < n) {
    return binarySearch_recursive(arr, n, midIndex + 1, highIndex);
  } else {
    return midIndex;
  }
}
```

### 11. íƒìš• ì•Œê³ ë¦¬ì¦˜

- **íƒìš• ì•Œê³ ë¦¬ì¦˜ :** ë§¤ ìˆœê°„ ìµœì  í•´ë¥¼ ì„ íƒí•˜ë©´ì„œ ìµœì¢…ì ìœ¼ë¡œ ìµœì í•´ì— ë„ë‹¬í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜ ì„¤ê³„ ê¸°ë²•
    
    **ğŸ“ íŠ¹ì§•**
    
    - ìµœì  ë¶€ë¶„ êµ¬ì¡°ë‚˜ íƒìš• ì„ íƒ ì†ì„± ë¬¸ì œë¥¼ í•´ê²°í•˜ëŠ”ë° ì í•©
    - ë§¤ ìˆœê°„ ìµœì  í•´ë¥¼ ì°¾ìœ¼ë©´ì„œ êµ¬í•˜ëŠ” ë°©ë²•ì´ í•­ìƒ ìµœì ì„ì„ ë³´ì¥í•˜ì§€ ì•Šì•„ ìœ ì˜ í•„ìš”

### 14. ë°±íŠ¸ë˜í‚¹

- **ë°±íŠ¸ë˜í‚¹ :** ê²½ìš°ì˜ ìˆ˜ë¡œ í•´ë¥¼ ì°¾ëŠ” ë„ì¤‘ í•´ê°€ ë‚˜ì˜¬ ìˆ˜ ì—†ëŠ” ì¡°ê±´ì¼ ë•Œ ì´ë¥¼ ì¤‘ë‹¨í•˜ê³  ë‹¤ë¥¸ ê²½ìš°ì˜ ìˆ˜ë¡œ í•´ë¥¼ ì°¾ëŠ” ì•Œê³ ë¦¬ì¦˜ ê¸°ë²•
    
    ğŸ“ **íŠ¹ì§•**
    
    - í•´ê°€ ë  ê°€ëŠ¥ì„±ì´ ìˆìœ¼ë©´ ì§€ì†ì  íƒìƒ‰, ê°€ëŠ¥ì„±ì´ ì—†ë‹¤ë©´ ê°€ì§€ì¹˜ê¸°í•˜ì—¬ ã…ƒë¥´ê²Œ ì „ì²´ í•´ë¥¼ íƒìƒ‰
    - í•´ê°€ ë˜ì§€ ì•ŠëŠ” ê²½ìš°ì˜ ìˆ˜ëŠ” ë°°ì¬í•˜ì—¬ í•´ë¥¼ ì°¾ëŠ” ì‹œê°„ ë³µì¡ë„ë¥¼ ë‹¨ì¶•

### 16. ë™ì ê³„íšë²•

- **ë™ì  ê²Œíšë²• :** Memoizationë¡œ ì¤‘ë³µ ì—°ì‚°ì„ ë°©ì§€í•˜ë©°, ì‘ì€ ë¶€ë¶„ ë¬¸ì œë¡œ í° ë¬¸ì œë¥¼ í•´ê²°í•˜ë©° í•´ë¥¼ ë„ì¶œí•˜ëŠ” ì•Œê³ ë¦¬ì¦˜ ì„¤ê³„ ê¸°ë²•
    
    **ğŸ“ íŠ¹ì§•**
    
    - ë¶€ë¬¸ ë¬¸ì œëŠ” ì¤‘ë³µë˜ë©°, ìƒìœ„ ë¬¸ì œ í•´ê²° ì‹œ ì¬ì‚¬ìš©
    - Memoization ê¸°ë²•ì„ ì‚¬ìš©(ë™ì¼í•œ ê³„ì‚°ì„ ë°˜ë³µí•  ë•Œ, ì´ì „ì— ê³„ì‚°í•œ ê°’ì„ ë©”ëª¨ë¦¬ì— ì €ì¥í•˜ì—¬ ì¤‘ë³µ ì—°ì‚°ì„ ë°©ì§€)
    
    **ğŸ“ êµ¬í˜„ ë°©ì‹**
    
    - Top-down : ì¬ê·€ë¥¼ í†µí•´ í° ë¬¸ì œë¥¼ ì‘ì€ ë¬¸ì œë¡œ ë‚˜ëˆ  í•´ê²°í•˜ë©° í•´ë¥¼ ì°¾ëŠ” ë°©ë²•
    - Bottom-up : ë°˜ë³µë¬¸ì„ í†µí•´ ì‘ì€ ë¬¸ì œë¶€í„° ì°¨ë¡€ëŒ€ë¡œ í•´ë¥¼ ì°¾ëŠ” ë°©ë²•

### 19. ìµœë‹¨ê²½ë¡œ

- ìµœë‹¨ê²½ë¡œ : ê°€ì¤‘ ê·¸ë˜í”„ì—ì„œ êµ¬ì„±í•˜ëŠ” ê°„ì„  ê°„ ê°€ì¤‘ì¹˜ í•©ì´ ìµœì†Œê°€ ë˜ë„ë¡ ìµœë‹¨ ê²½ë¡œë¥¼ ì°¾ëŠ” ì•Œê³ ë¦¬ì¦˜
    
    **ğŸ“ ìœ í˜•**
    
    - Dijkstra ì•Œê³ ë¦¬ì¦˜ : ê·¸ë˜í”„ì—ì„œ ì¶œë°œì ê³¼ ë„ì°©ì  ì‚¬ì´ì˜ ìµœë‹¨ ê±°ë¦¬ë¥¼ êµ¬í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜
        - ë³´í†µ ë‹¨ì¼ ì •ì  ê°„ ìµœë‹¨ ê²½ë¡œ ì‚°ì¶œ ì‹œ ì‚¬ìš©, ë„ë¡œ êµí†µë§ì´ë‚˜ OSPFë“±ì˜ ë„¤íŠ¸ì›Œí¬ ë¼ìš°íŒ… í”„ë¡œí† ì½œì— ë„ë¦¬ ì´ìš©
        
        ```jsx
        // ShortestPath(): edge object ê°ì²´ ì €ì¥ì„ ìœ„í•œ ìƒì„±ì
        // key: vertex
        // value: list í˜•íƒœë¡œ ì—°ê²°ëœ vertexë¥¼ í‘œí˜„í•˜ì—¬ edge ì—°ê²° ê´€ê³„ í‘œí˜„
        function ShortestPath() {
          this.edges = {};
        }
        // addVertex(): ì •ì  ì¶”ê°€ (ê°„ì„  ë¹„ìš© í‘œì‹œë¥¼ ìœ„í•´ key/value object í˜•íƒœë¡œ ì €ì¥)
        ShortestPath.prototype.addVertex = function (vertex) {
          this.edges[vertex] = {};
        };
        // addEdge(): ê°„ì„  ì¶”ê°€
        ShortestPath.prototype.addEdge = function (srcVertex, dstVertex, weight) {
          this.edges[srcVertex][dstVertex] = weight;
        };
        // _extractMin(): ìµœë‹¨ ê±°ë¦¬ ë…¸ë“œ ê²€ìƒ‰
        ShortestPath.prototype._extractMin = function (queue, dist) {
          let minDistance = Number.POSITIVE_INFINITY;
          let minVertex = null;
          for (let vertex in queue) {
            if (dist[vertex] <= minDistance) {
              minDistance = dist[vertex];
              minVertex = vertex;
            }
          }
          return minVertex;
        };
        // dijkstra(): ë‹¤ìµìŠ¤íŠ¸ë¼ ìµœë‹¨ ê²½ë¡œ íƒìƒ‰
        ShortestPath.prototype.dijkstra = function (start) {
          let queue = {};
          let dist = {};
          for (let vertex in this.edges) {
            dist[vertex] = Number.POSITIVE_INFINITY;
            queue[vertex] = this.edges[vertex];
          }
          dist[start] = 0;
          while (Object.keys(queue).length != 0) {
            let u = this._extractMin(queue, dist);
            delete queue[u];
            for (let neighbor in this.edges[u]) {
              let alt = dist[u] + this.edges[u][neighbor];
              if (alt < dist[neighbor]) dist[neighbor] = alt;
            }
          }
          for (let vertex in this.edges)
            if (dist[vertex] === Number.POSITIVE_INFINITY) delete dist[vertex];
          return dist;
        };
        ```
        
    - Floyd-Warshall ì•Œê³ ë¦¬ì¦˜ : ë™ì  ê²Œíšë²•ì„ í™œìš”í•´, ê·¸ë˜í”„ì—ì„œ ê°€ëŠ¥í•œ ëª¨ë“  ì •ì  ìŒì— ëŒ€í•´ ìµœë‹¨ ê±°ë¦¬ë¥¼ êµ¬í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜
        - ìŒì˜ ê°€ì¤‘ì¹˜ê°€ ìˆì–´ë„ ì‚¬ìš© ê°€ëŠ¥í•˜ë©°, ë§ì€ ìˆ˜ì˜ ê°„ì„ ìœ¼ë¡œ ì´ë£¨ì–´ì ¸ ìˆëŠ” ë°€ì§‘ ê·¸ë˜í”„ì— ì‚¬ìš© ì í•©
        
        ```jsx
        // floydWarshall(): í”Œë¡œì´ë“œ-ì›Œì…œ ìµœë‹¨ ê²½ë¡œ íƒìƒ‰
        ShortestPath.prototype.floydWarshall = function () {
          let dist = {};
          for (let srcVertex in this.edges) {
            dist[srcVertex] = {};
            for (let dstVertex in this.edges) {
              if (srcVertex === dstVertex) dist[srcVertex][dstVertex] = 0;
              else dist[srcVertex][dstVertex] = Number.POSITIVE_INFINITY;
            }
          }
          for (let srcVertex in this.edges) {
            for (let dstVertex in this.edges[srcVertex])
              dist[srcVertex][dstVertex] = this.edges[srcVertex][dstVertex];
          }
          for (let midVertex in this.edges)
            for (let srcVertex in this.edges)
              for (let dstVertex in this.edges)
                dist[srcVertex][dstVertex] = Math.min(
                  dist[srcVertex][dstVertex],
                  dist[srcVertex][midVertex] + dist[midVertex][dstVertex]
                );
          for (let srcVertex in this.edges)
            for (let dstVertex in this.edges)
              if (dist[srcVertex][dstVertex] === Number.POSITIVE_INFINITY)
                delete dist[srcVertex][dstVertex];
          return dist;
        };
        ```
        
    - A*ì•Œê³ ë¦¬ì¦˜ : íœ´ë¦¬ìŠ¤í‹± ë°©ë²• ì‚¬ìš©í•œ íƒìƒ‰
    - Bellman-Ford ì•Œê³ ë¦¬ì¦˜ : ìŒìˆ˜ ê°€ì¤‘ì¹˜ í—ˆìš©í•œ ë¹„ìš© ì‚°ì¶œ
    

### 24. ë¶„í• ì •ë³µ

- **ë¶„í• ì •ë³µ :** ë¬¸ì œë¥¼ ë‚˜ëˆŒ ìˆ˜ ì—†ì„ ë•Œê¹Œì§€ ì‘ê²Œ ë‚˜ëˆ„ê³  ë¶€ë¶„ ë¬¸ì œë¥¼ í•´ê²°í•˜ì—¬ ë³‘í•©í•´ í•´ë¥¼ ë„ì¶œí•˜ëŠ” ì•Œê³ ë¦¬ì¦˜ ì„¤ê³„ ê¸°ë²•
    
    **ğŸ“ íŠ¹ì§•**
    
    - í•˜í–¥ì‹ ì ‘ê·¼ë²•ìœ¼ë¡œ ìƒìœ„ í•´ë‹µì„ êµ¬í•˜ê¸° ìœ„í•´ ì•„ë˜ë¡œ ë‚´ë ¤ê°€ë©´ì„œ ë‹µì„ ë„ì¶œ
    - ë¶„í• í•œ ë¶€ë¶„ ë¬¸ì œê°€ ì„œë¡œ ì¤‘ë³µë˜ì§€ ì•Šì•„ ë¶€ë¬¸ í•´ í•´ê²°ì‹œ ìƒí˜¸ ì˜í–¥ ì—†ìŒ
